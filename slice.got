package slice¤a

// Here we have some utility slice routines

// Map provides an in-place map, meaning it modifies its input slice.
// If you still want that data, use the Map in package slices.
func Map(f func(¤a) ¤a, slice []¤a) {
	for i,v := range slice {
		slice[i] = f(v)
	}
}

func Fold(f func(¤a, ¤a) ¤a, id ¤a, slice []¤a) ¤a {
	x := id
  for _, v := range slice {
    x = f(x, v)
  }
  return x
}

// Filter returns a slice containing only those elements for which the
// predicate function returns true.
func Filter(f func(¤a) bool, slice []¤a) []¤a {
	out := make ([]¤a, 0, len(slice))
	i := 0
	for _,v := range slice {
		if f(v) {
			out = out[0:i+1]
			out[i] = v
			i++
		}
	}
	return out
}

// Append appends an element to a slice, in-place if possible, and
// expanding if needed.
func Append(slice []¤a, val ¤a) []¤a {
	length := len(slice)
	if cap(slice) == length {
		// we need to expand
		newsl := make([]¤a, length, 2*(length+1))
		for i,v := range slice {
			newsl[i] = v
		}
		slice = newsl
	}
	slice = slice[0:length+1]
	slice[length] = val
	return slice
}

// Cat concatenates two slices, expanding if needed.
func Cat(slice []¤a, more []¤a) []¤a {
	length1, length2 := len(slice), len(more)
	if cap(slice) <= length1 + length2 {
		// we need to expand
		newsl := make([]¤a, length1, 2*(length1+length2))
		for i,v := range slice {
			newsl[i] = v
		}
		slice = newsl
	}
	slice = slice[0:length1+length2]
	for i,v := range more {
		slice[length1+i] = v
	}
	return slice
}
